<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SVG地図境界作成</title>
  <style>
    :root {
      --bg: #0f1116;
      --panel: #171a22;
      --panel-border: #2a2f3a;
      --text: #e6e9ef;
      --muted: #9aa3b2;
      --accent: #6abf69;
      --warn: #e8b86c;
      --danger: #e06c75;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: var(--bg);
      color: var(--text);
      display: grid;
      grid-template-columns: 320px 1fr;
      height: 100vh;
    }
    aside {
      border-right: 1px solid var(--panel-border);
      background: var(--panel);
      padding: 16px;
      overflow: auto;
    }
    main {
      position: relative;
      overflow: hidden;
    }
    h1 {
      font-size: 18px;
      margin: 0 0 12px;
    }
    .group {
      border: 1px solid var(--panel-border);
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 12px;
      background: rgba(255, 255, 255, 0.02);
    }
    .group h2 {
      font-size: 13px;
      color: var(--muted);
      margin: 0 0 8px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    label {
      display: block;
      font-size: 12px;
      margin: 8px 0 4px;
    }
    input[type="number"], input[type="text"], input[type="file"], select {
      width: 100%;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid var(--panel-border);
      background: #10131a;
      color: var(--text);
    }
    input[type="checkbox"] {
      transform: translateY(2px);
      margin-right: 6px;
    }
    button {
      width: 100%;
      margin-top: 8px;
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid transparent;
      background: var(--accent);
      color: #0b0f10;
      font-weight: 600;
      cursor: pointer;
    }
    button.secondary {
      background: transparent;
      color: var(--text);
      border-color: var(--panel-border);
    }
    button.danger {
      background: var(--danger);
      color: #1a1113;
    }
    .note {
      font-size: 11px;
      color: var(--muted);
      line-height: 1.4;
    }
    .status {
      font-size: 12px;
      line-height: 1.4;
      background: #0b0f15;
      border: 1px solid var(--panel-border);
      padding: 8px;
      border-radius: 6px;
      white-space: pre-line;
    }
    .map-host {
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top left, rgba(106, 191, 105, 0.08), transparent 50%),
        radial-gradient(circle at bottom right, rgba(232, 184, 108, 0.08), transparent 50%);
      overflow: auto;
    }
    .svg-stack {
      position: relative;
      width: 100%;
      height: 100%;
      min-width: 600px;
      min-height: 400px;
    }
    .base-svg,
    .overlay-svg {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }
    .overlay-svg {
      pointer-events: none;
    }
    .legend {
      display: grid;
      gap: 6px;
    }
    .legend label {
      font-size: 12px;
      margin: 0;
    }
    .inline {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .inline label {
      margin: 0;
      flex: 1;
    }
  </style>
</head>
<body>
  <aside>
    <h1>SVG地図境界作成</h1>

    <div class="group">
      <h2>入力</h2>
      <label for="fileInput">SVGファイル</label>
      <input id="fileInput" type="file" accept="image/svg+xml" />
      <div class="note">Illustrator書き出しのSVG地図を読み込んで開始します。</div>
    </div>

    <div class="group">
      <h2>階層</h2>
      <div class="legend" id="layerToggles"></div>
    </div>

    <div class="group">
      <h2>間引き</h2>
      <label for="sampleStep">間引き間隔（地図単位）</label>
      <input id="sampleStep" type="number" min="0.2" step="0.2" value="1.2" />
      <label for="snapTolerance">吸着許容値（地図単位）</label>
      <input id="snapTolerance" type="number" min="0.05" step="0.05" value="0.25" />
      <label for="minArea">多角形の最小面積</label>
      <input id="minArea" type="number" min="0" step="10" value="50" />
      <label class="inline"><input id="includeCoast" type="checkbox" checked />陸地階層の海岸線を含める</label>
      <label class="inline"><input id="splitIntersections" type="checkbox" checked />線の交差で分割（推奨・遅い）</label>
    </div>

    <div class="group">
      <h2>操作</h2>
      <button id="buildGraphBtn">グラフを構築</button>
      <button id="extractBtn" class="secondary">多角形を抽出</button>
      <button id="exportBtn" class="secondary">JSONを書き出し</button>
      <button id="clearBtn" class="danger">重ね表示を消去</button>
    </div>

    <div class="group">
      <h2>表示</h2>
      <label class="inline"><input id="showEdges" type="checkbox" checked />辺を表示</label>
      <label class="inline"><input id="showPolys" type="checkbox" checked />多角形を表示</label>
      <label class="inline"><input id="showPoints" type="checkbox" />点を表示</label>
    </div>

    <div class="group">
      <h2>状態</h2>
      <div class="status" id="statusBox">SVGを待機中。</div>
    </div>
  </aside>

  <main>
    <div class="map-host">
      <div id="svgStack" class="svg-stack"></div>
    </div>
  </main>

  <svg id="measure" width="0" height="0" style="position:absolute; left:-9999px; top:-9999px;"></svg>

  <script>
    const state = {
      svgText: null,
      svgDoc: null,
      baseSvg: null,
      overlaySvg: null,
      viewBox: null,
      graph: null,
      polygons: [],
    };
    let buildGraphInProgress = false;

    const layerDefs = [
      { id: "_海", label: "海" },
      { id: "_第一分高面", label: "第一分高面" },
      { id: "_第二分高面", label: "第二分高面" },
      { id: "_第三分高面", label: "第三分高面" },
      { id: "_第四分高面", label: "第四分高面" },
      { id: "_第五分高面", label: "第五分高面" },
      { id: "_国境界", label: "国境界" },
    ];

    const el = {
      fileInput: document.getElementById("fileInput"),
      layerToggles: document.getElementById("layerToggles"),
      sampleStep: document.getElementById("sampleStep"),
      snapTolerance: document.getElementById("snapTolerance"),
      minArea: document.getElementById("minArea"),
      includeCoast: document.getElementById("includeCoast"),
      splitIntersections: document.getElementById("splitIntersections"),
      buildGraphBtn: document.getElementById("buildGraphBtn"),
      extractBtn: document.getElementById("extractBtn"),
      exportBtn: document.getElementById("exportBtn"),
      clearBtn: document.getElementById("clearBtn"),
      showEdges: document.getElementById("showEdges"),
      showPolys: document.getElementById("showPolys"),
      showPoints: document.getElementById("showPoints"),
      statusBox: document.getElementById("statusBox"),
      svgStack: document.getElementById("svgStack"),
      measureSvg: document.getElementById("measure"),
    };

    function setStatus(message) {
      el.statusBox.textContent = message;
    }

    function formatProgress(done, total) {
      if (!Number.isFinite(total) || total <= 0) return "";
      const pct = Math.round((done / total) * 100);
      return `${done}/${total} (${pct}%)`;
    }

    function setBuildStatus(lines) {
      const body = lines.filter(Boolean);
      setStatus(["グラフを構築中...", ...body].join("\n"));
    }

    function nextFrame() {
      return new Promise((resolve) => requestAnimationFrame(() => resolve()));
    }

    function readFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error);
        reader.readAsText(file);
      });
    }

    function clearOverlays() {
      if (!state.overlaySvg) return;
      state.overlaySvg.innerHTML = "";
    }

    function loadSvgText(text) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(text, "image/svg+xml");
      const svg = doc.documentElement;
      if (!svg || svg.nodeName.toLowerCase() !== "svg") {
        throw new Error("Invalid SVG file.");
      }

      state.svgText = text;
      state.svgDoc = doc;
      state.viewBox = svg.getAttribute("viewBox") || `0 0 ${svg.getAttribute("width")} ${svg.getAttribute("height")}`;

      el.svgStack.innerHTML = "";

      const baseSvg = svg.cloneNode(true);
      baseSvg.setAttribute("preserveAspectRatio", "xMidYMid meet");
      baseSvg.classList.add("base-svg");
      baseSvg.removeAttribute("width");
      baseSvg.removeAttribute("height");

      const overlaySvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      overlaySvg.setAttribute("viewBox", state.viewBox);
      overlaySvg.classList.add("overlay-svg");

      el.svgStack.appendChild(baseSvg);
      el.svgStack.appendChild(overlaySvg);

      state.baseSvg = baseSvg;
      state.overlaySvg = overlaySvg;

      buildLayerToggles();
      setStatus("SVGを読み込みました。階層を選んでグラフを構築してください。");
    }

    function buildLayerToggles() {
      el.layerToggles.innerHTML = "";
      layerDefs.forEach((layer) => {
        const wrapper = document.createElement("label");
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.checked = true;
        checkbox.dataset.layerId = layer.id;
        checkbox.addEventListener("change", () => toggleLayer(layer.id, checkbox.checked));
        wrapper.appendChild(checkbox);
        wrapper.appendChild(document.createTextNode(layer.label));
        el.layerToggles.appendChild(wrapper);
      });
    }

    function toggleLayer(layerId, visible) {
      if (!state.baseSvg) return;
      const target = state.baseSvg.getElementById(layerId);
      if (target) {
        target.style.display = visible ? "inline" : "none";
      }
    }

    function getLayer(layerId) {
      if (!state.svgDoc) return null;
      return state.svgDoc.getElementById(layerId) || state.svgDoc.querySelector(`[data-name='${layerId}']`);
    }

    function splitPathData(d) {
      if (!d) return [];
      const parts = d.trim().split(/(?=M)/).map((part) => part.trim()).filter(Boolean);
      return parts;
    }

    function samplePathElement(pathEl, step, pathDataOverride) {
      const clone = pathEl.cloneNode(true);
      if (pathDataOverride) {
        clone.setAttribute("d", pathDataOverride);
      }
      el.measureSvg.appendChild(clone);
      const length = clone.getTotalLength();
      const count = Math.max(2, Math.ceil(length / step));
      const points = [];
      for (let i = 0; i <= count; i += 1) {
        const raw = clone.getPointAtLength((length * i) / count);
        points.push(applyTransform(raw, clone));
      }
      el.measureSvg.removeChild(clone);
      return points;
    }

    function samplePolylineElement(polyEl) {
      const clone = polyEl.cloneNode(true);
      el.measureSvg.appendChild(clone);
      const points = [];
      const raw = clone.getAttribute("points") || "";
      const parts = raw.trim().split(/[\s,]+/).filter(Boolean);
      for (let i = 0; i < parts.length; i += 2) {
        const x = Number(parts[i]);
        const y = Number(parts[i + 1]);
        if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
        points.push(applyTransform({ x, y }, clone));
      }
      el.measureSvg.removeChild(clone);
      return points;
    }

    function sampleLineElement(lineEl) {
      const clone = lineEl.cloneNode(true);
      el.measureSvg.appendChild(clone);
      const x1 = Number(clone.getAttribute("x1"));
      const y1 = Number(clone.getAttribute("y1"));
      const x2 = Number(clone.getAttribute("x2"));
      const y2 = Number(clone.getAttribute("y2"));
      const pts = [
        applyTransform({ x: x1, y: y1 }, clone),
        applyTransform({ x: x2, y: y2 }, clone),
      ];
      el.measureSvg.removeChild(clone);
      return pts;
    }

    function applyTransform(point, element) {
      const ctm = element.getCTM();
      if (!ctm) return { x: point.x, y: point.y };
      const svgPoint = el.measureSvg.createSVGPoint();
      svgPoint.x = point.x;
      svgPoint.y = point.y;
      const out = svgPoint.matrixTransform(ctm);
      return { x: out.x, y: out.y };
    }

    async function extractSegmentsFromLayer(layerEl, step, sourceTag, onProgress) {
      const segments = [];
      const elements = Array.from(layerEl.querySelectorAll("path, polyline, polygon, line"));
      const total = elements.length;
      const yieldEvery = 20;

      const pushSegments = (points) => {
        const cleaned = removeSequentialDuplicates(points, 1e-6);
        for (let i = 0; i < cleaned.length - 1; i += 1) {
          segments.push({
            a: cleaned[i],
            b: cleaned[i + 1],
            source: sourceTag,
          });
        }
      };

      for (let index = 0; index < total; index += 1) {
        const item = elements[index];
        const tag = item.tagName.toLowerCase();
        if (tag === "path") {
          const d = item.getAttribute("d") || "";
          const subpaths = splitPathData(d);
          if (subpaths.length === 1) {
            const points = samplePathElement(item, step, subpaths[0]);
            pushSegments(points);
          } else if (subpaths.length > 1) {
            // Illustratorなどが複数サブパスを1つのpathに入れるため分割する。
            subpaths.forEach((subpath) => {
              const points = samplePathElement(item, step, subpath);
              pushSegments(points);
            });
          }
        } else if (tag === "polyline" || tag === "polygon") {
          const points = samplePolylineElement(item);
          if (tag === "polygon" && points.length > 2) {
            points.push(points[0]);
          }
          pushSegments(points);
        } else if (tag === "line") {
          const points = sampleLineElement(item);
          pushSegments(points);
        }

        if (onProgress && (index % yieldEvery === 0 || index === total - 1)) {
          onProgress(index + 1, total);
          await nextFrame();
        }
      }
      return segments;
    }

    function removeSequentialDuplicates(points, eps) {
      if (points.length === 0) return points;
      const output = [points[0]];
      for (let i = 1; i < points.length; i += 1) {
        if (distance(points[i], output[output.length - 1]) > eps) {
          output.push(points[i]);
        }
      }
      return output;
    }

    function distance(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.hypot(dx, dy);
    }

    async function splitSegmentsAtIntersections(segments, gridSize, onProgress) {
      const segIntersections = new Map();
      const grid = new Map();

      function gridKey(x, y) {
        return `${x},${y}`;
      }

      function addToGrid(idx, seg) {
        const minX = Math.min(seg.a.x, seg.b.x);
        const maxX = Math.max(seg.a.x, seg.b.x);
        const minY = Math.min(seg.a.y, seg.b.y);
        const maxY = Math.max(seg.a.y, seg.b.y);
        const x0 = Math.floor(minX / gridSize);
        const x1 = Math.floor(maxX / gridSize);
        const y0 = Math.floor(minY / gridSize);
        const y1 = Math.floor(maxY / gridSize);
        for (let gx = x0; gx <= x1; gx += 1) {
          for (let gy = y0; gy <= y1; gy += 1) {
            const key = gridKey(gx, gy);
            if (!grid.has(key)) grid.set(key, []);
            grid.get(key).push(idx);
          }
        }
      }

      const gridYield = 800;
      for (let i = 0; i < segments.length; i += 1) {
        addToGrid(i, segments[i]);
        if (onProgress && (i % gridYield === 0 || i === segments.length - 1)) {
          onProgress("グリッド構築中", i + 1, segments.length);
          await nextFrame();
        }
      }

      const checked = new Set();
      const buckets = Array.from(grid.values());
      const bucketYield = 40;
      for (let bucketIndex = 0; bucketIndex < buckets.length; bucketIndex += 1) {
        const bucket = buckets[bucketIndex];
        for (let i = 0; i < bucket.length; i += 1) {
          for (let j = i + 1; j < bucket.length; j += 1) {
            const a = bucket[i];
            const b = bucket[j];
            const key = a < b ? `${a}-${b}` : `${b}-${a}`;
            if (checked.has(key)) continue;
            checked.add(key);
            const segA = segments[a];
            const segB = segments[b];
            const hit = segmentIntersection(segA.a, segA.b, segB.a, segB.b);
            if (!hit) continue;
            if (!segIntersections.has(a)) segIntersections.set(a, []);
            if (!segIntersections.has(b)) segIntersections.set(b, []);
            segIntersections.get(a).push(hit.t1);
            segIntersections.get(b).push(hit.t2);
          }
        }
        if (onProgress && (bucketIndex % bucketYield === 0 || bucketIndex === buckets.length - 1)) {
          onProgress("交差判定中", bucketIndex + 1, buckets.length);
          await nextFrame();
        }
      }

      const output = [];
      const splitYield = 1000;
      for (let idx = 0; idx < segments.length; idx += 1) {
        const seg = segments[idx];
        const splits = segIntersections.get(idx) || [];
        const sorted = [0, 1, ...splits.filter((t) => t > 1e-6 && t < 1 - 1e-6)].sort((a, b) => a - b);
        for (let i = 0; i < sorted.length - 1; i += 1) {
          const t0 = sorted[i];
          const t1 = sorted[i + 1];
          const p0 = lerpPoint(seg.a, seg.b, t0);
          const p1 = lerpPoint(seg.a, seg.b, t1);
          if (distance(p0, p1) > 1e-6) {
            output.push({ a: p0, b: p1, source: seg.source });
          }
        }
        if (onProgress && (idx % splitYield === 0 || idx === segments.length - 1)) {
          onProgress("分割反映中", idx + 1, segments.length);
          await nextFrame();
        }
      }

      return output;
    }

    function lerpPoint(a, b, t) {
      return {
        x: a.x + (b.x - a.x) * t,
        y: a.y + (b.y - a.y) * t,
      };
    }

    function segmentIntersection(p1, p2, p3, p4) {
      const dx1 = p2.x - p1.x;
      const dy1 = p2.y - p1.y;
      const dx2 = p4.x - p3.x;
      const dy2 = p4.y - p3.y;
      const denom = dx1 * dy2 - dy1 * dx2;
      if (Math.abs(denom) < 1e-9) return null;

      const dx3 = p1.x - p3.x;
      const dy3 = p1.y - p3.y;
      const t1 = (dx2 * dy3 - dy2 * dx3) / denom;
      const t2 = (dx1 * dy3 - dy1 * dx3) / denom;
      if (t1 < 0 || t1 > 1 || t2 < 0 || t2 > 1) return null;

      return { t1, t2 };
    }

    async function buildGraph() {
      if (buildGraphInProgress) {
        setStatus("グラフ構築中です。完了を待ってください。");
        return;
      }
      if (!state.svgDoc) {
        setStatus("先にSVGファイルを読み込んでください。");
        return;
      }
      const step = Number(el.sampleStep.value);
      const snap = Number(el.snapTolerance.value);
      const includeCoast = el.includeCoast.checked;
      const split = el.splitIntersections.checked;

      const borderLayer = getLayer("_国境界");
      if (!borderLayer) {
        setStatus("国境界の階層（_国境界）が見つかりません。");
        return;
      }

      buildGraphInProgress = true;
      el.buildGraphBtn.disabled = true;
      el.extractBtn.disabled = true;
      el.exportBtn.disabled = true;

      const updateProgress = (phase, done, total, extra) => {
        const progress = formatProgress(done, total);
        setBuildStatus([phase, progress, extra]);
      };

      try {
        state.graph = null;
        state.polygons = [];
        clearOverlays();
        setBuildStatus(["準備中..."]);
        await nextFrame();

        let segments = [];

        updateProgress("国境界を抽出中", 0, 0);
        const borderSegments = await extractSegmentsFromLayer(borderLayer, step, "border", (done, total) => {
          updateProgress("国境界を抽出中", done, total);
        });
        segments = segments.concat(borderSegments);

        let coastLayerId = null;
        if (includeCoast) {
          const landLayerIds = ["_第一分高面", "_第二分高面", "_第三分高面", "_第四分高面", "_第五分高面"];
          let coastLayer = null;
          for (let i = 0; i < landLayerIds.length; i += 1) {
            const id = landLayerIds[i];
            const layer = getLayer(id);
            if (layer) {
              coastLayer = layer;
              coastLayerId = id;
              break;
            }
          }

          if (coastLayer) {
            const label = `海岸線(${coastLayerId})を抽出中`;
            const layerSegments = await extractSegmentsFromLayer(coastLayer, step, "coast", (done, total) => {
              updateProgress(label, done, total);
            });
            segments = segments.concat(layerSegments);
            await nextFrame();
          } else {
            updateProgress("海岸線レイヤーが見つかりません", 0, 0);
          }
        }

        if (split) {
          const gridSize = Math.max(step * 2, snap * 4, 1);
          segments = await splitSegmentsAtIntersections(segments, gridSize, (phase, done, total) => {
            updateProgress(`交差分割: ${phase}`, done, total);
          });
        }

        const pointGrid = new Map();
        const points = [];
        const pointHits = [];
        const edges = [];
        const edgeMap = new Map();
        const cellSize = snap;

        function gridKey(x, y) {
          return `${x}:${y}`;
        }

        function addPoint(pt) {
          const cx = Math.floor(pt.x / cellSize);
          const cy = Math.floor(pt.y / cellSize);
          let bestIdx = null;
          let bestDist = Infinity;

          for (let dx = -1; dx <= 1; dx += 1) {
            for (let dy = -1; dy <= 1; dy += 1) {
              const key = gridKey(cx + dx, cy + dy);
              const candidates = pointGrid.get(key);
              if (!candidates) continue;
              for (let i = 0; i < candidates.length; i += 1) {
                const idx = candidates[i];
                const d = distance(pt, points[idx]);
                if (d <= snap && d < bestDist) {
                  bestDist = d;
                  bestIdx = idx;
                }
              }
            }
          }

          if (bestIdx === null) {
            const idx = points.length;
            points.push({ x: pt.x, y: pt.y });
            pointHits.push(1);
            const key = gridKey(cx, cy);
            if (!pointGrid.has(key)) pointGrid.set(key, []);
            pointGrid.get(key).push(idx);
            return idx;
          }

          const hits = pointHits[bestIdx] + 1;
          points[bestIdx].x = (points[bestIdx].x * pointHits[bestIdx] + pt.x) / hits;
          points[bestIdx].y = (points[bestIdx].y * pointHits[bestIdx] + pt.y) / hits;
          pointHits[bestIdx] = hits;
          return bestIdx;
        }

        updateProgress("点と辺を構築中", 0, segments.length, `線分: ${segments.length}`);
        const buildYield = 2000;
        for (let i = 0; i < segments.length; i += 1) {
          const seg = segments[i];
          const a = addPoint(seg.a);
          const b = addPoint(seg.b);
          if (a === b) continue;
          const key = a < b ? `${a}-${b}` : `${b}-${a}`;
          let edge = edgeMap.get(key);
          if (!edge) {
            edge = { a, b, sources: new Set() };
            edgeMap.set(key, edge);
            edges.push(edge);
          }
          edge.sources.add(seg.source);

          if (i % buildYield === 0 || i === segments.length - 1) {
            updateProgress("点と辺を構築中", i + 1, segments.length, `線分: ${segments.length}`);
            await nextFrame();
          }
        }

        state.graph = { points, edges };
        state.polygons = [];
        clearOverlays();
        drawEdges();

        setStatus([
          `グラフを構築しました。`,
          `点: ${points.length}`,
          `辺: ${edges.length}`,
          `線分: ${segments.length}`,
          includeCoast
            ? coastLayerId
              ? `海岸線(${coastLayerId})を含めました。`
              : "海岸線レイヤーが見つからず除外しました。"
            : "海岸線を除外しました。",
        ].join("\n"));
      } catch (error) {
        setStatus(`グラフ構築に失敗しました: ${error.message}`);
      } finally {
        buildGraphInProgress = false;
        el.buildGraphBtn.disabled = false;
        el.extractBtn.disabled = false;
        el.exportBtn.disabled = false;
      }
    }

    function extractPolygons() {
      if (!state.graph) {
        setStatus("先にグラフを構築してください。");
        return;
      }

      const { points, edges } = state.graph;
      const minArea = Number(el.minArea.value);

      const directed = [];
      const outgoing = Array.from({ length: points.length }, () => []);

      edges.forEach((edge, edgeIndex) => {
        const a = edge.a;
        const b = edge.b;
        const angleAB = Math.atan2(points[b].y - points[a].y, points[b].x - points[a].x);
        const angleBA = Math.atan2(points[a].y - points[b].y, points[a].x - points[b].x);
        const idxAB = directed.length;
        directed.push({ from: a, to: b, angle: angleAB, edgeIndex });
        const idxBA = directed.length;
        directed.push({ from: b, to: a, angle: angleBA, edgeIndex });
        outgoing[a].push(idxAB);
        outgoing[b].push(idxBA);
      });

      outgoing.forEach((list) => list.sort((i, j) => directed[i].angle - directed[j].angle));

      const adjacency = Array.from({ length: points.length }, () => []);
      edges.forEach((edge) => {
        adjacency[edge.a].push(edge.b);
        adjacency[edge.b].push(edge.a);
      });

      const components = new Array(points.length).fill(-1);
      let componentId = 0;
      for (let i = 0; i < points.length; i += 1) {
        if (components[i] !== -1) continue;
        if (adjacency[i].length === 0) continue;
        const stack = [i];
        components[i] = componentId;
        while (stack.length) {
          const v = stack.pop();
          const neighbors = adjacency[v];
          for (let j = 0; j < neighbors.length; j += 1) {
            const next = neighbors[j];
            if (components[next] === -1) {
              components[next] = componentId;
              stack.push(next);
            }
          }
        }
        componentId += 1;
      }

      function nextEdgeIndex(dirIndex) {
        const dir = directed[dirIndex];
        const v = dir.to;
        const incomingAngle = Math.atan2(points[dir.from].y - points[v].y, points[dir.from].x - points[v].x);
        const list = outgoing[v];
        if (!list || list.length === 0) return null;
        let chosen = list[list.length - 1];
        for (let i = 0; i < list.length; i += 1) {
          const candidate = list[i];
          if (directed[candidate].angle < incomingAngle - 1e-10) {
            chosen = candidate;
          } else {
            break;
          }
        }
        return chosen;
      }

      const visited = new Array(directed.length).fill(false);
      const faces = [];

      for (let i = 0; i < directed.length; i += 1) {
        if (visited[i]) continue;
        const face = [];
        let current = i;
        let guard = 0;
        while (!visited[current] && guard < directed.length + 10) {
          visited[current] = true;
          const edge = directed[current];
          face.push(edge.from);
          const next = nextEdgeIndex(current);
          if (next === null) break;
          current = next;
          guard += 1;
          if (current === i) break;
        }

        if (face.length < 3) continue;
        const area = polygonArea(face, points);
        if (Math.abs(area) < minArea) continue;
        faces.push({ points: face, area, component: components[face[0]] });
      }

      if (faces.length === 0) {
        setStatus("多角形が見つかりません。間引き設定を調整するか海岸線を有効にしてください。");
        return;
      }

      const outerFaces = new Set();
      const faceGroups = new Map();
      faces.forEach((face) => {
        const key = face.component;
        if (!faceGroups.has(key)) faceGroups.set(key, []);
        faceGroups.get(key).push(face);
      });
      faceGroups.forEach((group) => {
        const largest = group.reduce((max, face) => (Math.abs(face.area) > Math.abs(max.area) ? face : max), group[0]);
        outerFaces.add(largest);
      });
      const polygons = faces.filter((face) => !outerFaces.has(face));

      state.polygons = polygons.map((face, idx) => {
        return {
          id: idx + 1,
          area: face.area,
          points: face.points,
        };
      });

      clearOverlays();
      drawEdges();
      drawPolygons();
      drawPoints();

      setStatus([
        `多角形を抽出しました: ${state.polygons.length}`,
        outerFaces.size === 1
          ? `外側の面を除外しました: 面積 ${Array.from(outerFaces)[0].area.toFixed(2)}`
          : `外側の面を除外しました: ${outerFaces.size}面`,
        `最小面積: ${minArea}`,
      ].join("\n"));
    }

    function polygonArea(indices, points) {
      let sum = 0;
      for (let i = 0; i < indices.length; i += 1) {
        const a = points[indices[i]];
        const b = points[indices[(i + 1) % indices.length]];
        sum += (a.x * b.y - b.x * a.y);
      }
      return sum / 2;
    }

    function drawEdges() {
      if (!state.graph || !state.overlaySvg) return;
      if (!el.showEdges.checked) return;

      const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
      group.setAttribute("stroke", "#f5f5f5");
      group.setAttribute("stroke-width", "0.3");
      group.setAttribute("fill", "none");
      group.setAttribute("opacity", "0.8");

      state.graph.edges.forEach((edge) => {
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        const a = state.graph.points[edge.a];
        const b = state.graph.points[edge.b];
        line.setAttribute("x1", a.x);
        line.setAttribute("y1", a.y);
        line.setAttribute("x2", b.x);
        line.setAttribute("y2", b.y);
        if (edge.sources.has("coast")) {
          line.setAttribute("stroke", "#6abf69");
          line.setAttribute("stroke-width", "0.4");
        }
        group.appendChild(line);
      });

      state.overlaySvg.appendChild(group);
    }

    function drawPolygons() {
      if (!state.polygons.length || !el.showPolys.checked) return;
      const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
      group.setAttribute("fill", "rgba(232, 184, 108, 0.25)");
      group.setAttribute("stroke", "#e8b86c");
      group.setAttribute("stroke-width", "0.6");

      state.polygons.forEach((poly) => {
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        const d = poly.points.map((idx, i) => {
          const p = state.graph.points[idx];
          return `${i === 0 ? "M" : "L"}${p.x} ${p.y}`;
        }).join(" ") + " Z";
        path.setAttribute("d", d);
        path.setAttribute("fill", randomFill(poly.id));
        path.setAttribute("fill-opacity", "0.25");
        group.appendChild(path);
      });

      state.overlaySvg.appendChild(group);
    }

    function randomFill(id) {
      const hue = (id * 47) % 360;
      return `hsl(${hue} 60% 60%)`;
    }

    function drawPoints() {
      if (!state.graph || !el.showPoints.checked) return;
      const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
      group.setAttribute("fill", "#6abf69");

      state.graph.points.forEach((pt) => {
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", pt.x);
        circle.setAttribute("cy", pt.y);
        circle.setAttribute("r", "0.4");
        group.appendChild(circle);
      });

      state.overlaySvg.appendChild(group);
    }

    function exportJson() {
      if (!state.graph || !state.polygons.length) {
        setStatus("先にグラフを構築して多角形を抽出してください。");
        return;
      }

      const edgeOutput = state.graph.edges.map((edge) => ({
        a: edge.a,
        b: edge.b,
        sources: Array.from(edge.sources),
      }));

      const payload = {
        meta: {
          createdAt: new Date().toISOString(),
          sampleStep: Number(el.sampleStep.value),
          snapTolerance: Number(el.snapTolerance.value),
          coastlineIncluded: el.includeCoast.checked,
        },
        points: state.graph.points.map((pt) => ({ x: pt.x, y: pt.y })),
        edges: edgeOutput,
        polygons: state.polygons,
      };

      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = "borders.json";
      document.body.appendChild(link);
      link.click();
      link.remove();
      URL.revokeObjectURL(url);

      setStatus("borders.jsonを書き出しました。");
    }

    el.fileInput.addEventListener("change", async (event) => {
      const file = event.target.files[0];
      if (!file) return;
      try {
        const text = await readFile(file);
        loadSvgText(text);
      } catch (error) {
        setStatus(`SVGの読み込みに失敗しました: ${error.message}`);
      }
    });

    el.buildGraphBtn.addEventListener("click", buildGraph);
    el.extractBtn.addEventListener("click", extractPolygons);
    el.exportBtn.addEventListener("click", exportJson);
    el.clearBtn.addEventListener("click", () => {
      clearOverlays();
      setStatus("重ね表示を消去しました。");
    });

    [el.showEdges, el.showPolys, el.showPoints].forEach((checkbox) => {
      checkbox.addEventListener("change", () => {
        clearOverlays();
        drawEdges();
        drawPolygons();
        drawPoints();
      });
    });
  </script>
</body>
</html>
