<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SVG地図境界作成</title>
  <style>
    :root {
      --bg: #0f1116;
      --panel: #171a22;
      --panel-border: #2a2f3a;
      --text: #e6e9ef;
      --muted: #9aa3b2;
      --accent: #6abf69;
      --warn: #e8b86c;
      --danger: #e06c75;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: var(--bg);
      color: var(--text);
      display: grid;
      grid-template-columns: 320px 1fr;
      height: 100vh;
    }
    aside {
      border-right: 1px solid var(--panel-border);
      background: var(--panel);
      padding: 16px;
      overflow: auto;
    }
    main {
      position: relative;
      overflow: hidden;
    }
    h1 {
      font-size: 18px;
      margin: 0 0 12px;
    }
    .group {
      border: 1px solid var(--panel-border);
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 12px;
      background: rgba(255, 255, 255, 0.02);
    }
    .group h2 {
      font-size: 13px;
      color: var(--muted);
      margin: 0 0 8px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    label {
      display: block;
      font-size: 12px;
      margin: 8px 0 4px;
    }
    input[type="number"], input[type="text"], input[type="file"], select {
      width: 100%;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid var(--panel-border);
      background: #10131a;
      color: var(--text);
    }
    input[type="checkbox"] {
      transform: translateY(2px);
      margin-right: 6px;
    }
    button {
      width: 100%;
      margin-top: 8px;
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid transparent;
      background: var(--accent);
      color: #0b0f10;
      font-weight: 600;
      cursor: pointer;
    }
    button.secondary {
      background: transparent;
      color: var(--text);
      border-color: var(--panel-border);
    }
    button.danger {
      background: var(--danger);
      color: #1a1113;
    }
    .note {
      font-size: 11px;
      color: var(--muted);
      line-height: 1.4;
    }
    .status {
      font-size: 12px;
      line-height: 1.4;
      background: #0b0f15;
      border: 1px solid var(--panel-border);
      padding: 8px;
      border-radius: 6px;
      white-space: pre-line;
    }
    .map-host {
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top left, rgba(106, 191, 105, 0.08), transparent 50%),
        radial-gradient(circle at bottom right, rgba(232, 184, 108, 0.08), transparent 50%);
      overflow: auto;
    }
    .svg-stack {
      position: relative;
      width: 100%;
      height: 100%;
      min-width: 600px;
      min-height: 400px;
    }
    .base-svg,
    .overlay-svg {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }
    .overlay-svg {
      pointer-events: auto;
    }
    .edge-layer,
    .point-layer,
    .polygon-highlight {
      pointer-events: none;
    }
    .polygon-layer path {
      cursor: pointer;
    }
    .legend {
      display: grid;
      gap: 6px;
    }
    .type-legend {
      display: none;
      gap: 6px;
      margin-top: 6px;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid var(--panel-border);
      background: rgba(255, 255, 255, 0.02);
    }
    .type-legend-title {
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    .type-legend-items {
      display: grid;
      gap: 4px;
    }
    .type-legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: var(--text);
    }
    .type-legend-swatch {
      width: 12px;
      height: 12px;
      border-radius: 2px;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    .legend label {
      font-size: 12px;
      margin: 0;
    }
    .layer-actions {
      display: grid;
      gap: 6px;
      margin-top: 10px;
    }
    .layer-actions button {
      margin-top: 0;
    }
    .inline {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .inline label {
      margin: 0;
      flex: 1;
    }
  </style>
</head>
<body>
  <aside>
    <h1>SVG地図境界作成</h1>

    <div class="group">
      <h2>入力</h2>
      <label for="fileInput">SVGファイル</label>
      <input id="fileInput" type="file" accept="image/svg+xml" />
      <div class="note">Illustrator書き出しのSVG地図を読み込んで開始します。</div>
    </div>

    <div class="group">
      <h2>階層</h2>
      <div class="legend" id="layerToggles"></div>
      <div class="layer-actions">
        <button id="toggleLandBtn" class="secondary" disabled>分高面をまとめて切り替え</button>
        <button id="toggleOtherBtn" class="secondary" disabled>その他レイヤーをまとめて切り替え</button>
      </div>
    </div>

    <div class="group">
      <h2>間引き</h2>
      <label for="sampleStep">間引き間隔（地図単位）</label>
      <input id="sampleStep" type="number" min="0.2" step="0.2" value="1.2" />
      <label for="snapTolerance">吸着許容値（地図単位）</label>
      <input id="snapTolerance" type="number" min="0.05" step="0.05" value="1" />
      <label class="inline"><input id="includeCoast" type="checkbox" checked />陸地階層の海岸線を含める</label>
      <label class="inline"><input id="splitIntersections" type="checkbox" checked />線の交差で分割（推奨・遅い）</label>
    </div>

    <div class="group">
      <h2>操作</h2>
      <button id="buildGraphBtn">グラフを構築</button>
      <button id="extractBtn" class="secondary">多角形を抽出</button>
      <button id="exportBtn" class="secondary">JSONを書き出し</button>
      <button id="clearBtn" class="danger">重ね表示を消去</button>
    </div>

    <div class="group">
      <h2>表示</h2>
      <label class="inline"><input id="showEdges" type="checkbox" checked />辺を表示</label>
      <label class="inline"><input id="showPolys" type="checkbox" checked />多角形を表示</label>
      <label class="inline"><input id="showTypes" type="checkbox" />国タイプで色分け（デバッグ）</label>
      <div id="typeLegend" class="type-legend">
        <div class="type-legend-title">凡例</div>
        <div id="typeLegendItems" class="type-legend-items"></div>
      </div>
      <label class="inline"><input id="showPoints" type="checkbox" />点を表示</label>
    </div>

    <div class="group">
      <h2>状態</h2>
      <div class="status" id="statusBox">SVGを待機中。</div>
    </div>
  </aside>

  <main>
    <div id="mapHost" class="map-host">
      <div id="svgStack" class="svg-stack"></div>
    </div>
  </main>

  <svg id="measure" width="0" height="0" style="position:absolute; left:-9999px; top:-9999px;"></svg>

  <script src="logic.js"></script>
  <script>
    const state = {
      svgText: null,
      svgDoc: null,
      baseSvg: null,
      overlaySvg: null,
      viewBox: null,
      graph: null,
      polygons: [],
      polygonsGroup: null,
      polygonPaths: new Map(),
      polygonEdgeIndex: null,
      polygonTypes: new Map(),
      selectedPolygons: new Set(),
      selectionOverlay: null,
      selectionBoundary: null,
      sharedSeaInfo: null,
      zoom: 1,
      layerCheckboxes: new Map(),
      otherLayerElements: [],
    };
    let buildGraphInProgress = false;

    const layerDefs = [
      { id: "_海", label: "海" },
      { id: "_第一分高面", label: "第一分高面" },
      { id: "_第二分高面", label: "第二分高面" },
      { id: "_第三分高面", label: "第三分高面" },
      { id: "_第四分高面", label: "第四分高面" },
      { id: "_第五分高面", label: "第五分高面" },
      { id: "_国境界", label: "国境界" },
    ];
    const landLayerIds = ["_第一分高面", "_第二分高面", "_第三分高面", "_第四分高面", "_第五分高面"];

    const el = {
      fileInput: document.getElementById("fileInput"),
      layerToggles: document.getElementById("layerToggles"),
      sampleStep: document.getElementById("sampleStep"),
      snapTolerance: document.getElementById("snapTolerance"),
      includeCoast: document.getElementById("includeCoast"),
      splitIntersections: document.getElementById("splitIntersections"),
      buildGraphBtn: document.getElementById("buildGraphBtn"),
      extractBtn: document.getElementById("extractBtn"),
      exportBtn: document.getElementById("exportBtn"),
      clearBtn: document.getElementById("clearBtn"),
      toggleLandBtn: document.getElementById("toggleLandBtn"),
      toggleOtherBtn: document.getElementById("toggleOtherBtn"),
      showEdges: document.getElementById("showEdges"),
      showPolys: document.getElementById("showPolys"),
      showTypes: document.getElementById("showTypes"),
      showPoints: document.getElementById("showPoints"),
      statusBox: document.getElementById("statusBox"),
      typeLegend: document.getElementById("typeLegend"),
      typeLegendItems: document.getElementById("typeLegendItems"),
      mapHost: document.getElementById("mapHost"),
      svgStack: document.getElementById("svgStack"),
      measureSvg: document.getElementById("measure"),
    };

    DerleLogic.setMeasureSvg(el.measureSvg);

    function setStatus(message) {
      el.statusBox.textContent = message;
    }

    function formatProgress(done, total) {
      if (!Number.isFinite(total) || total <= 0) return "";
      const pct = Math.round((done / total) * 100);
      return `${done}/${total} (${pct}%)`;
    }

    function setBuildStatus(lines) {
      const body = lines.filter(Boolean);
      setStatus(["グラフを構築中...", ...body].join("\n"));
    }

    const ZOOM_MIN = 0.5;
    const ZOOM_MAX = 20;
    const ZOOM_SENSITIVITY = 0.002;

    function applyZoom(nextZoom, anchor) {
      const host = el.mapHost;
      if (!host) return;
      const clamped = Math.min(ZOOM_MAX, Math.max(ZOOM_MIN, nextZoom));
      if (Math.abs(clamped - state.zoom) < 1e-4) return;
      const rect = host.getBoundingClientRect();
      const offsetX = anchor ? anchor.x - rect.left : rect.width / 2;
      const offsetY = anchor ? anchor.y - rect.top : rect.height / 2;
      const startX = host.scrollLeft + offsetX;
      const startY = host.scrollTop + offsetY;
      const scale = clamped / state.zoom;

      state.zoom = clamped;
      el.svgStack.style.width = `${clamped * 100}%`;
      el.svgStack.style.height = `${clamped * 100}%`;

      host.scrollLeft = startX * scale - offsetX;
      host.scrollTop = startY * scale - offsetY;
    }

    function resetZoom() {
      state.zoom = 1;
      el.svgStack.style.width = "100%";
      el.svgStack.style.height = "100%";
      if (el.mapHost) {
        el.mapHost.scrollLeft = 0;
        el.mapHost.scrollTop = 0;
      }
    }

    function handleWheelZoom(event) {
      if (!state.baseSvg) return;
      event.preventDefault();
      const delta = event.deltaMode === 1 ? event.deltaY * 16 : event.deltaY;
      if (!Number.isFinite(delta) || delta === 0) return;
      const factor = Math.exp(-delta * ZOOM_SENSITIVITY);
      applyZoom(state.zoom * factor, { x: event.clientX, y: event.clientY });
    }

    const GEOM_EPS = 1e-6;

    function pointOnSegment(point, a, b, tol) {
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const len2 = dx * dx + dy * dy;
      const tol2 = tol * tol;
      if (len2 <= tol2) {
        const dist2 = (point.x - a.x) ** 2 + (point.y - a.y) ** 2;
        return dist2 <= tol2;
      }
      const t = ((point.x - a.x) * dx + (point.y - a.y) * dy) / len2;
      if (t < 0 || t > 1) return false;
      const projX = a.x + dx * t;
      const projY = a.y + dy * t;
      const dist2 = (point.x - projX) ** 2 + (point.y - projY) ** 2;
      return dist2 <= tol2;
    }

    function pointInPolygon(point, indices, points, tol) {
      let inside = false;
      for (let i = 0, j = indices.length - 1; i < indices.length; j = i++) {
        const a = points[indices[i]];
        const b = points[indices[j]];
        if (!a || !b) continue;
        if (tol > 0 && pointOnSegment(point, a, b, tol)) {
          return true;
        }
        const intersects = (a.y > point.y) !== (b.y > point.y)
          && point.x < ((b.x - a.x) * (point.y - a.y)) / (b.y - a.y) + a.x;
        if (intersects) inside = !inside;
      }
      return inside;
    }

    function buildPolygonData(polygons, points) {
      return polygons.map((poly) => {
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        for (let i = 0; i < poly.points.length; i += 1) {
          const p = points[poly.points[i]];
          if (!p) continue;
          if (p.x < minX) minX = p.x;
          if (p.y < minY) minY = p.y;
          if (p.x > maxX) maxX = p.x;
          if (p.y > maxY) maxY = p.y;
        }
        return { points: poly.points, minX, minY, maxX, maxY };
      });
    }

    function findPolygonIndex(point, polygonData, points, tol) {
      for (let i = 0; i < polygonData.length; i += 1) {
        const poly = polygonData[i];
        if (point.x < poly.minX - tol || point.x > poly.maxX + tol
          || point.y < poly.minY - tol || point.y > poly.maxY + tol) {
          continue;
        }
        if (pointInPolygon(point, poly.points, points, tol)) {
          return i;
        }
      }
      return -1;
    }

    function collectSharedSeaPolygons(borderGraph, borderPolygons, snap) {
      if (!borderGraph || borderPolygons.length === 0) {
        return { polygonData: [], sharedPolygons: new Set(), tolerance: 0 };
      }
      const degrees = new Array(borderGraph.points.length).fill(0);
      borderGraph.edges.forEach((edge) => {
        degrees[edge.a] += 1;
        degrees[edge.b] += 1;
      });
      const polygonData = buildPolygonData(borderPolygons, borderGraph.points);
      const tolerance = Math.max(GEOM_EPS, snap * 0.1);
      const sharedPolygons = new Set();

      borderGraph.edges.forEach((edge) => {
        if (degrees[edge.a] !== 1 && degrees[edge.b] !== 1) return;
        const a = borderGraph.points[edge.a];
        const b = borderGraph.points[edge.b];
        const mid = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
        const idx = findPolygonIndex(mid, polygonData, borderGraph.points, tolerance);
        if (idx >= 0) {
          sharedPolygons.add(idx);
        }
      });

      return { polygonData, sharedPolygons, tolerance };
    }

    function filterCoastSegments(segments, polygonData, points, sharedPolygons, tolerance) {
      if (!polygonData.length) return segments;
      const filtered = [];
      for (let i = 0; i < segments.length; i += 1) {
        const seg = segments[i];
        const mid = { x: (seg.a.x + seg.b.x) / 2, y: (seg.a.y + seg.b.y) / 2 };
        const idx = findPolygonIndex(mid, polygonData, points, tolerance);
        if (idx === -1 || sharedPolygons.has(idx)) {
          filtered.push(seg);
        }
      }
      return filtered;
    }

    function readFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error);
        reader.readAsText(file);
      });
    }

    function clearOverlays() {
      if (!state.overlaySvg) return;
      state.overlaySvg.innerHTML = "";
      state.polygonsGroup = null;
      state.polygonPaths.clear();
      state.selectedPolygons.clear();
      state.selectionOverlay = null;
      state.selectionBoundary = null;
    }

    function parseViewBox(viewBox) {
      if (!viewBox) return null;
      const parts = viewBox.trim().split(/[\s,]+/).map(Number);
      if (parts.length !== 4 || parts.some((v) => !Number.isFinite(v))) return null;
      return { x: parts[0], y: parts[1], width: parts[2], height: parts[3] };
    }

    function edgeKey(a, b) {
      return a < b ? `${a}-${b}` : `${b}-${a}`;
    }

    function buildPolygonEdgeIndex(polygons, graph) {
      if (!graph) return null;
      const edgeSources = new Map();
      graph.edges.forEach((edge) => {
        edgeSources.set(edgeKey(edge.a, edge.b), edge.sources);
      });

      const edgeToPolys = new Map();
      polygons.forEach((poly) => {
        const polyId = String(poly.id);
        const pts = poly.points;
        for (let i = 0; i < pts.length; i += 1) {
          const a = pts[i];
          const b = pts[(i + 1) % pts.length];
          const key = edgeKey(a, b);
          if (!edgeToPolys.has(key)) {
            edgeToPolys.set(key, { a, b, polys: new Set() });
          }
          edgeToPolys.get(key).polys.add(polyId);
        }
      });

      return { edgeSources, edgeToPolys };
    }

    function classifyPolygons(polygons, graph, edgeSources, sharedSeaInfo) {
      const types = new Map();
      polygons.forEach((poly) => {
        const polyId = String(poly.id);
        let hasBorder = false;
        let hasCoast = false;
        let touchesSharedSea = false;

        for (let i = 0; i < poly.points.length; i += 1) {
          const aIdx = poly.points[i];
          const bIdx = poly.points[(i + 1) % poly.points.length];
          const sources = edgeSources.get(edgeKey(aIdx, bIdx));
          if (!sources) continue;
          if (sources.has("border")) hasBorder = true;
          if (sources.has("coast")) {
            hasCoast = true;
            if (!touchesSharedSea && sharedSeaInfo && sharedSeaInfo.polygonData.length) {
              const a = graph.points[aIdx];
              const b = graph.points[bIdx];
              const mid = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
              const idx = findPolygonIndex(mid, sharedSeaInfo.polygonData, sharedSeaInfo.points, sharedSeaInfo.tolerance);
              if (idx >= 0 && sharedSeaInfo.sharedPolygons.has(idx)) {
                touchesSharedSea = true;
              }
            }
          }
        }

        let type = "不明";
        if (hasBorder && hasCoast) {
          type = touchesSharedSea ? "共有する海" : "海岸線まで国境界";
        } else if (hasBorder) {
          type = "海まで国境線";
        } else if (hasCoast) {
          type = "島国";
        }
        types.set(polyId, type);
      });

      return types;
    }

    function updatePolygonStrokes() {
      const selected = state.selectedPolygons;
      state.polygonPaths.forEach((path, id) => {
        if (selected.has(id)) {
          path.setAttribute("stroke", "none");
        } else {
          path.setAttribute("stroke", path.dataset.stroke || "#e8b86c");
          path.setAttribute("stroke-width", path.dataset.strokeWidth || "0.6");
        }
      });
    }

    function updateSelectionOverlay() {
      if (!state.overlaySvg) return;
      if (state.selectionOverlay && state.selectionOverlay.parentNode) {
        state.selectionOverlay.parentNode.removeChild(state.selectionOverlay);
      }
      state.selectionOverlay = null;
      if (state.selectedPolygons.size === 0) return;

      const vb = parseViewBox(state.viewBox);
      if (!vb) return;
      const dParts = [
        `M${vb.x} ${vb.y} H${vb.x + vb.width} V${vb.y + vb.height} H${vb.x} Z`,
      ];
      state.selectedPolygons.forEach((id) => {
        const path = state.polygonPaths.get(id);
        if (path) {
          dParts.push(path.getAttribute("d"));
        }
      });
      const overlay = document.createElementNS("http://www.w3.org/2000/svg", "path");
      overlay.setAttribute("d", dParts.join(" "));
      overlay.setAttribute("fill", "rgba(0, 0, 0, 0.35)");
      overlay.setAttribute("fill-rule", "evenodd");
      overlay.classList.add("polygon-highlight");
      overlay.setAttribute("pointer-events", "none");
      state.overlaySvg.appendChild(overlay);
      state.selectionOverlay = overlay;
    }

    function updateSelectionBoundary() {
      if (!state.overlaySvg) return;
      if (state.selectionBoundary && state.selectionBoundary.parentNode) {
        state.selectionBoundary.parentNode.removeChild(state.selectionBoundary);
      }
      state.selectionBoundary = null;
      if (!state.graph || !state.polygonEdgeIndex || state.selectedPolygons.size === 0) return;

      const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
      group.setAttribute("fill", "none");
      group.setAttribute("stroke", "#e8b86c");
      group.setAttribute("stroke-width", "0.6");
      group.setAttribute("pointer-events", "none");

      state.polygonEdgeIndex.edgeToPolys.forEach((info) => {
        if (info.polys.size !== 1) return;
        let onlyPolyId = null;
        info.polys.forEach((id) => {
          onlyPolyId = id;
        });
        if (!state.selectedPolygons.has(onlyPolyId)) return;
        const a = state.graph.points[info.a];
        const b = state.graph.points[info.b];
        if (!a || !b) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", a.x);
        line.setAttribute("y1", a.y);
        line.setAttribute("x2", b.x);
        line.setAttribute("y2", b.y);
        group.appendChild(line);
      });

      state.overlaySvg.appendChild(group);
      state.selectionBoundary = group;
    }

    function updateSelectionDisplay() {
      updatePolygonStrokes();
      updateSelectionOverlay();
      updateSelectionBoundary();
    }

    function handleOverlayClick(event) {
      if (!state.polygonsGroup) return;
      const target = event.target instanceof Element ? event.target : null;
      const path = target ? target.closest("path[data-poly-id]") : null;
      if (!path || !state.polygonsGroup.contains(path)) {
        if (!event.shiftKey && state.selectedPolygons.size) {
          state.selectedPolygons.clear();
          updateSelectionDisplay();
        }
        return;
      }
      const polyId = path.dataset.polyId;
      if (!polyId) return;
      const additive = event.shiftKey;
      if (additive) {
        if (state.selectedPolygons.has(polyId)) {
          state.selectedPolygons.delete(polyId);
        } else {
          state.selectedPolygons.add(polyId);
        }
      } else {
        if (state.selectedPolygons.size === 1 && state.selectedPolygons.has(polyId)) {
          state.selectedPolygons.clear();
        } else {
          state.selectedPolygons.clear();
          state.selectedPolygons.add(polyId);
        }
      }
      updateSelectionDisplay();
    }

    function loadSvgText(text) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(text, "image/svg+xml");
      const svg = doc.documentElement;
      if (!svg || svg.nodeName.toLowerCase() !== "svg") {
        throw new Error("Invalid SVG file.");
      }

      state.svgText = text;
      state.svgDoc = doc;
      state.viewBox = svg.getAttribute("viewBox") || `0 0 ${svg.getAttribute("width")} ${svg.getAttribute("height")}`;

      el.svgStack.innerHTML = "";

      const baseSvg = svg.cloneNode(true);
      baseSvg.setAttribute("preserveAspectRatio", "xMidYMid meet");
      baseSvg.classList.add("base-svg");
      baseSvg.removeAttribute("width");
      baseSvg.removeAttribute("height");

      const overlaySvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      overlaySvg.setAttribute("viewBox", state.viewBox);
      overlaySvg.classList.add("overlay-svg");
      overlaySvg.addEventListener("click", handleOverlayClick);

      el.svgStack.appendChild(baseSvg);
      el.svgStack.appendChild(overlaySvg);

      state.baseSvg = baseSvg;
      state.overlaySvg = overlaySvg;
      resetZoom();

      buildLayerToggles();
      refreshLayerGroupControls();
      setStatus("SVGを読み込みました。階層を選んでグラフを構築してください。");
    }

    function buildLayerToggles() {
      el.layerToggles.innerHTML = "";
      state.layerCheckboxes.clear();
      layerDefs.forEach((layer) => {
        const wrapper = document.createElement("label");
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.checked = true;
        checkbox.dataset.layerId = layer.id;
        checkbox.addEventListener("change", () => toggleLayer(layer.id, checkbox.checked));
        wrapper.appendChild(checkbox);
        wrapper.appendChild(document.createTextNode(layer.label));
        el.layerToggles.appendChild(wrapper);
        state.layerCheckboxes.set(layer.id, checkbox);
      });
    }

    function toggleLayer(layerId, visible) {
      setLayerVisibility(layerId, visible);
    }

    function setLayerVisibility(layerId, visible) {
      if (!state.baseSvg) return;
      const target = state.baseSvg.getElementById(layerId);
      if (target) {
        target.style.display = visible ? "inline" : "none";
      }
      const checkbox = state.layerCheckboxes.get(layerId);
      if (checkbox) {
        checkbox.checked = visible;
      }
    }

    function toggleLayerGroup(layerIds) {
      if (!state.baseSvg) {
        setStatus("先にSVGファイルを読み込んでください。");
        return;
      }
      const existing = layerIds
        .map((id) => ({ id, el: state.baseSvg.getElementById(id) }))
        .filter((entry) => entry.el);
      if (!existing.length) {
        setStatus("対象のレイヤーが見つかりません。");
        return;
      }
      const allVisible = existing.every((entry) => entry.el.style.display !== "none");
      const nextVisible = !allVisible;
      existing.forEach((entry) => setLayerVisibility(entry.id, nextVisible));
    }

    function collectOtherLayerElements() {
      if (!state.baseSvg) return [];
      const definedIds = new Set(layerDefs.map((layer) => layer.id));
      const definedElements = layerDefs
        .map((layer) => state.baseSvg.getElementById(layer.id))
        .filter(Boolean);
      const candidates = Array.from(state.baseSvg.querySelectorAll("g[id]"))
        .filter((el) => !definedIds.has(el.id))
        .filter((el) => !el.closest("defs"));
      const filtered = candidates.filter((el) => {
        if (definedElements.some((def) => el.contains(def))) return false;
        if (definedElements.some((def) => def.contains(el))) return false;
        return true;
      });
      const filteredSet = new Set(filtered);
      return filtered.filter((el) => {
        let parent = el.parentElement;
        while (parent && parent !== state.baseSvg) {
          if (filteredSet.has(parent)) return false;
          parent = parent.parentElement;
        }
        return true;
      });
    }

    function refreshLayerGroupControls() {
      if (!state.baseSvg) {
        el.toggleLandBtn.disabled = true;
        el.toggleOtherBtn.disabled = true;
        state.otherLayerElements = [];
        return;
      }
      const hasLandLayers = landLayerIds.some((id) => state.baseSvg.getElementById(id));
      el.toggleLandBtn.disabled = !hasLandLayers;
      state.otherLayerElements = collectOtherLayerElements();
      el.toggleOtherBtn.disabled = state.otherLayerElements.length === 0;
    }

    function toggleOtherLayers() {
      if (!state.baseSvg) {
        setStatus("先にSVGファイルを読み込んでください。");
        return;
      }
      const targets = state.otherLayerElements || [];
      if (!targets.length) {
        setStatus("その他レイヤーが見つかりません。");
        return;
      }
      const allVisible = targets.every((el) => el.style.display !== "none");
      const nextVisible = !allVisible;
      targets.forEach((el) => {
        el.style.display = nextVisible ? "inline" : "none";
      });
    }

    function getLayer(layerId) {
      if (!state.svgDoc) return null;
      return state.svgDoc.getElementById(layerId) || state.svgDoc.querySelector(`[data-name='${layerId}']`);
    }

    async function buildGraph() {
      if (buildGraphInProgress) {
        setStatus("グラフ構築中です。完了を待ってください。");
        return;
      }
      if (!state.svgDoc) {
        setStatus("先にSVGファイルを読み込んでください。");
        return;
      }
      const step = Number(el.sampleStep.value);
      const snap = Number(el.snapTolerance.value);
      const minArea = 0;
      const includeCoast = el.includeCoast.checked;
      const split = el.splitIntersections.checked;

      const borderLayer = getLayer("_国境界");
      if (!borderLayer) {
        setStatus("国境界の階層（_国境界）が見つかりません。");
        return;
      }

      buildGraphInProgress = true;
      el.buildGraphBtn.disabled = true;
      el.extractBtn.disabled = true;
      el.exportBtn.disabled = true;

      const updateProgress = (phase, done, total, extra) => {
        const progress = formatProgress(done, total);
        setBuildStatus([phase, progress, extra]);
      };
      const splitPhaseLabel = {
        grid: "グリッド構築中",
        intersections: "交差判定中",
        split: "分割反映中",
      };

      try {
        state.graph = null;
        state.polygons = [];
        state.sharedSeaInfo = null;
        state.polygonEdgeIndex = null;
        state.polygonTypes.clear();
        clearOverlays();
        setBuildStatus(["準備中..."]);
        await DerleLogic.nextFrame();

        let segments = [];
        let borderSegments = [];
        let coastSegments = [];
        let coastLayerId = null;
        let excludedCoastCount = 0;
        let sharedSeaCount = 0;
        let sharedInfo = null;
        let borderGraph = null;

        updateProgress("国境界を抽出中", 0, 0);
        borderSegments = await DerleLogic.extractSegmentsFromLayer(borderLayer, step, "border", (done, total) => {
          updateProgress("国境界を抽出中", done, total);
        });
        segments = segments.concat(borderSegments);

        if (includeCoast) {
          let coastLayer = null;
          for (let i = 0; i < landLayerIds.length; i += 1) {
            const id = landLayerIds[i];
            const layer = getLayer(id);
            if (layer) {
              coastLayer = layer;
              coastLayerId = id;
              break;
            }
          }

          if (coastLayer) {
            const label = `海岸線(${coastLayerId})を抽出中`;
            coastSegments = await DerleLogic.extractSegmentsFromLayer(coastLayer, step, "coast", (done, total) => {
              updateProgress(label, done, total);
            });
            segments = segments.concat(coastSegments);
            await DerleLogic.nextFrame();
          } else {
            updateProgress("海岸線レイヤーが見つかりません", 0, 0);
          }
        }

        if (split) {
          const gridSize = Math.max(step * 2, snap * 4, 1);
          segments = await DerleLogic.splitSegmentsAtIntersections(segments, gridSize, snap, (phase, done, total) => {
            const label = splitPhaseLabel[phase] || phase;
            updateProgress(`交差分割: ${label}`, done, total);
          });
        }

        let finalSegments = segments;
        if (includeCoast && coastSegments.length) {
          const borderOnlySegments = segments.filter((seg) => seg.source === "border");
          const coastOnlySegments = segments.filter((seg) => seg.source === "coast");

          updateProgress("国境線の構造解析中", 0, borderOnlySegments.length);
          borderGraph = await DerleLogic.buildGraphFromSegments(borderOnlySegments, snap, (done, total) => {
            updateProgress("国境線の構造解析中", done, total);
          });
          const borderResult = DerleLogic.extractPolygonsFromGraph(borderGraph, minArea);
          sharedInfo = collectSharedSeaPolygons(borderGraph, borderResult.polygons, snap);
          sharedSeaCount = sharedInfo.sharedPolygons.size;

          const filteredCoastSegments = filterCoastSegments(
            coastOnlySegments,
            sharedInfo.polygonData,
            borderGraph.points,
            sharedInfo.sharedPolygons,
            sharedInfo.tolerance,
          );
          excludedCoastCount = coastOnlySegments.length - filteredCoastSegments.length;
          finalSegments = borderOnlySegments.concat(filteredCoastSegments);
        }

        updateProgress("点と辺を構築中", 0, finalSegments.length, `線分: ${finalSegments.length}`);
        const graph = await DerleLogic.buildGraphFromSegments(finalSegments, snap, (done, total) => {
          updateProgress("点と辺を構築中", done, total, `線分: ${finalSegments.length}`);
        });

        state.graph = graph;
        state.sharedSeaInfo = sharedInfo && borderGraph
          ? { ...sharedInfo, points: borderGraph.points }
          : null;
        state.polygons = [];
        clearOverlays();
        drawEdges();

        let coastMessage = "";
        if (!includeCoast) {
          coastMessage = "海岸線を除外しました。";
        } else if (!coastLayerId) {
          coastMessage = "海岸線レイヤーが見つからず除外しました。";
        } else {
          const detail = (excludedCoastCount > 0 || sharedSeaCount > 0)
            ? `内側除外: ${excludedCoastCount}本 / 共有海: ${sharedSeaCount}面`
            : null;
          coastMessage = detail
            ? `海岸線(${coastLayerId})を含めました。${detail}`
            : `海岸線(${coastLayerId})を含めました。`;
        }

        setStatus([
          `グラフを構築しました。`,
          `点: ${graph.points.length}`,
          `辺: ${graph.edges.length}`,
          `線分: ${finalSegments.length}`,
          coastMessage,
        ].join("\n"));
      } catch (error) {
        setStatus(`グラフ構築に失敗しました: ${error.message}`);
      } finally {
        buildGraphInProgress = false;
        el.buildGraphBtn.disabled = false;
        el.extractBtn.disabled = false;
        el.exportBtn.disabled = false;
      }
    }

    function extractPolygons() {
      if (!state.graph) {
        setStatus("先にグラフを構築してください。");
        return;
      }

      const minArea = 0;
      const result = DerleLogic.extractPolygonsFromGraph(state.graph, minArea);
      if (result.polygons.length === 0 && result.outerFaces.length === 0) {
        setStatus("多角形が見つかりません。間引き設定を調整するか海岸線を有効にしてください。");
        return;
      }

      state.polygons = result.polygons.map((face, idx) => {
        return {
          id: idx + 1,
          area: face.area,
          points: face.points,
          fill: randomFill(idx + 1),
        };
      });

      clearOverlays();
      state.polygonEdgeIndex = null;
      state.polygonTypes.clear();
      state.polygonEdgeIndex = buildPolygonEdgeIndex(state.polygons, state.graph);
      if (state.polygonEdgeIndex) {
        state.polygonTypes = classifyPolygons(
          state.polygons,
          state.graph,
          state.polygonEdgeIndex.edgeSources,
          state.sharedSeaInfo,
        );
      }
      drawEdges();
      drawPolygons();
      drawPoints();

      const outerCount = result.outerFaces.length;
      const outerMessage = outerCount === 0
        ? "外側の面が見つかりませんでした。"
        : outerCount === 1
          ? `外側の面を除外しました: 面積 ${result.outerFaces[0].area.toFixed(2)}`
          : `外側の面を除外しました: ${outerCount}面`;

      setStatus([
        `多角形を抽出しました: ${state.polygons.length}`,
        outerMessage,
      ].join("\n"));
    }

    function drawEdges() {
      if (!state.graph || !state.overlaySvg) return;
      if (!el.showEdges.checked) return;

      const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
      group.classList.add("edge-layer");
      group.setAttribute("stroke", "#f5f5f5");
      group.setAttribute("stroke-width", "0.3");
      group.setAttribute("fill", "none");
      group.setAttribute("opacity", "0.8");
      group.setAttribute("pointer-events", "none");

      state.graph.edges.forEach((edge) => {
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        const a = state.graph.points[edge.a];
        const b = state.graph.points[edge.b];
        line.setAttribute("x1", a.x);
        line.setAttribute("y1", a.y);
        line.setAttribute("x2", b.x);
        line.setAttribute("y2", b.y);
        if (edge.sources.has("coast")) {
          line.setAttribute("stroke", "#6abf69");
          line.setAttribute("stroke-width", "0.4");
        }
        group.appendChild(line);
      });

      state.overlaySvg.appendChild(group);
    }

    function drawPolygons() {
      if (!state.polygons.length || !el.showPolys.checked) return;
      const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
      group.classList.add("polygon-layer");
      group.setAttribute("fill", "rgba(232, 184, 108, 0.25)");
      group.setAttribute("stroke", "#e8b86c");
      group.setAttribute("stroke-width", "0.6");
      state.polygonPaths.clear();

      state.polygons.forEach((poly) => {
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        const d = poly.points.map((idx, i) => {
          const p = state.graph.points[idx];
          return `${i === 0 ? "M" : "L"}${p.x} ${p.y}`;
        }).join(" ") + " Z";
        path.setAttribute("d", d);
        path.setAttribute("fill", getPolygonFill(poly));
        path.setAttribute("fill-opacity", "0.25");
        path.dataset.stroke = "#e8b86c";
        path.dataset.strokeWidth = "0.6";
        path.dataset.polyId = String(poly.id);
        state.polygonPaths.set(String(poly.id), path);
        group.appendChild(path);
      });

      state.overlaySvg.appendChild(group);
      state.polygonsGroup = group;
      updateSelectionDisplay();
    }

    function randomFill(id) {
      const hue = (id * 47) % 360;
      return `hsl(${hue} 60% 60%)`;
    }

    const POLY_TYPE_COLORS = {
      "海まで国境線": "#5b8def",
      "海岸線まで国境界": "#e8b86c",
      "共有する海": "#6abf69",
      "島国": "#d48b5f",
      "不明": "#9aa3b2",
    };
    const POLY_TYPE_ORDER = [
      "海まで国境線",
      "海岸線まで国境界",
      "共有する海",
      "島国",
      "不明",
    ];

    function buildTypeLegend() {
      if (!el.typeLegendItems) return;
      el.typeLegendItems.innerHTML = "";
      POLY_TYPE_ORDER.forEach((label) => {
        const row = document.createElement("div");
        row.classList.add("type-legend-item");
        const swatch = document.createElement("span");
        swatch.classList.add("type-legend-swatch");
        swatch.style.background = POLY_TYPE_COLORS[label] || POLY_TYPE_COLORS["不明"];
        const text = document.createElement("span");
        text.textContent = label;
        row.appendChild(swatch);
        row.appendChild(text);
        el.typeLegendItems.appendChild(row);
      });
    }

    function updateTypeLegendVisibility() {
      if (!el.typeLegend) return;
      el.typeLegend.style.display = el.showTypes.checked ? "grid" : "none";
    }

    function getPolygonFill(poly) {
      if (el.showTypes.checked) {
        const type = state.polygonTypes.get(String(poly.id)) || "不明";
        return POLY_TYPE_COLORS[type] || POLY_TYPE_COLORS["不明"];
      }
      return poly.fill || randomFill(poly.id);
    }

    function updatePolygonFills() {
      state.polygons.forEach((poly) => {
        const path = state.polygonPaths.get(String(poly.id));
        if (!path) return;
        path.setAttribute("fill", getPolygonFill(poly));
      });
    }

    function drawPoints() {
      if (!state.graph || !el.showPoints.checked) return;
      const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
      group.classList.add("point-layer");
      group.setAttribute("fill", "#6abf69");
      group.setAttribute("pointer-events", "none");

      state.graph.points.forEach((pt) => {
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", pt.x);
        circle.setAttribute("cy", pt.y);
        circle.setAttribute("r", "0.4");
        group.appendChild(circle);
      });

      state.overlaySvg.appendChild(group);
    }

    function exportJson() {
      if (!state.graph || !state.polygons.length) {
        setStatus("先にグラフを構築して多角形を抽出してください。");
        return;
      }

      const edgeOutput = state.graph.edges.map((edge) => ({
        a: edge.a,
        b: edge.b,
        sources: Array.from(edge.sources),
      }));

      const payload = {
        meta: {
          createdAt: new Date().toISOString(),
          sampleStep: Number(el.sampleStep.value),
          snapTolerance: Number(el.snapTolerance.value),
          coastlineIncluded: el.includeCoast.checked,
        },
        points: state.graph.points.map((pt) => ({ x: pt.x, y: pt.y })),
        edges: edgeOutput,
        polygons: state.polygons,
      };

      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = "borders.json";
      document.body.appendChild(link);
      link.click();
      link.remove();
      URL.revokeObjectURL(url);

      setStatus("borders.jsonを書き出しました。");
    }

    el.fileInput.addEventListener("change", async (event) => {
      const file = event.target.files[0];
      if (!file) return;
      try {
        const text = await readFile(file);
        loadSvgText(text);
      } catch (error) {
        setStatus(`SVGの読み込みに失敗しました: ${error.message}`);
      }
    });

    el.buildGraphBtn.addEventListener("click", buildGraph);
    el.extractBtn.addEventListener("click", extractPolygons);
    el.exportBtn.addEventListener("click", exportJson);
    el.clearBtn.addEventListener("click", () => {
      clearOverlays();
      setStatus("重ね表示を消去しました。");
    });
    el.toggleLandBtn.addEventListener("click", () => toggleLayerGroup(landLayerIds));
    el.toggleOtherBtn.addEventListener("click", toggleOtherLayers);
    el.mapHost.addEventListener("wheel", handleWheelZoom, { passive: false });
    el.showTypes.addEventListener("change", () => {
      updatePolygonFills();
      updateTypeLegendVisibility();
    });

    [el.showEdges, el.showPolys, el.showPoints].forEach((checkbox) => {
      checkbox.addEventListener("change", () => {
        clearOverlays();
        drawEdges();
        drawPolygons();
        drawPoints();
      });
    });

    buildTypeLegend();
    updateTypeLegendVisibility();
  </script>
</body>
</html>
